#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DRAW_KEY_LEFT   GLFW_KEY_LEFT
#define DRAW_KEY_UP     GLFW_KEY_UP
#define DRAW_KEY_RIGHT  GLFW_KEY_RIGHT
#define DRAW_KEY_DOWN   GLFW_KEY_DOWN
#define DRAW_KEY_ENTER  GLFW_KEY_ENTER
#define DRAW_KEY_SPACE  GLFW_KEY_SPACE
#define DRAW_KEY_ESCAPE GLFW_KEY_ESCAPE


int DRAW_COORD_HEIGHT;
int DRAW_COORD_WIDTH;


GLuint uniColor;
GLuint offsetx;
GLuint offsety;
GLuint coords;
GLuint shaderProgram;
GLuint vertexShader;
GLuint fragmentShader;
GLuint vbo;
GLuint vao;
GLFWwindow* window;
float verts[] = 
{
	 0.8,  0.8,
	 0.8, -0.8,
	-0.8,  0.8,

	
	 0.8, -0.8,
	-0.8,  0.8,
	-0.8, -0.8
};

GLchar* read_shader(const GLchar* source);



void draw_set_coord_size(int a, int b)
{
	DRAW_COORD_WIDTH  = a;
	DRAW_COORD_HEIGHT = b;
}

void draw_swap_buffers()
{
	glfwSwapBuffers(window);
}

void draw_fill_square(int j, int i)
{
	/* 
	verts[0]  = i/(DRAW_COORD_WIDTH/2.0) - 1 + 0.3/DRAW_COORD_WIDTH;
	verts[1]  = 1 - j/(DRAW_COORD_HEIGHT/2.0) - 0.3/DRAW_COORD_HEIGHT;

	verts[5]  = (i + 1)/(DRAW_COORD_WIDTH/2.0) - 1 - 0.3/DRAW_COORD_WIDTH;
	verts[6]  = 1 - j/(DRAW_COORD_HEIGHT/2.0) - 0.3/DRAW_COORD_HEIGHT;
	
	verts[10] = (i + 1)/(DRAW_COORD_WIDTH/2.0) - 1 - 0.3/DRAW_COORD_WIDTH;
	verts[11] = 1 - (j + 1)/(DRAW_COORD_HEIGHT/2.0) + 0.3/DRAW_COORD_HEIGHT;
	


	verts[15] = (i + 1)/(DRAW_COORD_WIDTH/2.0) - 1 - 0.3/DRAW_COORD_WIDTH;
	verts[16] = 1 - (j + 1)/(DRAW_COORD_HEIGHT/2.0) + 0.3/DRAW_COORD_HEIGHT;
	
	verts[20] = i/(DRAW_COORD_WIDTH/2.0) - 1 + 0.3/DRAW_COORD_WIDTH;
	verts[21] = 1 - (j + 1)/(DRAW_COORD_HEIGHT/2.0) + 0.3/DRAW_COORD_HEIGHT;

	verts[25] = i/(DRAW_COORD_WIDTH/2.0) - 1 + 0.3/DRAW_COORD_WIDTH;
	verts[26] = 1 - j/(DRAW_COORD_HEIGHT/2.0) - 0.3/DRAW_COORD_HEIGHT;
	
	
	
	glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);
	glDrawArrays(GL_TRIANGLES, 0, 6);
	/* */
}


void draw_wait(int ms)
{
	long startd = 1000*clock()/1000;

	while (1000*clock()/1000 - startd < ms)
		glfwPollEvents();
}

void draw_square(int j, int i)
{
	//glUniform2i(coords, 0, 0);	
	glUniform2i(coords, j, i);	
	
	glDrawArrays(GL_TRIANGLES, 0, 6);
}

void draw_square_area(int x1, int y1, int x2, int y2)
{
	int i, j;
	for (i = y1; i < y2; i++)
	for (j = x1; j < x2; j++)
	{
		draw_square(i, j);
	}
}

void draw_clear()
{
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
}

void draw_change_color(float r, float g, float b)
{
	glUniform3f(uniColor, r, g, b);
}


int draw_is_pressed(int key)
{
	return glfwGetKey(window, key) == GLFW_PRESS;
}

void draw_init(int _width, int _height)
{
	/* */
	verts[0]  = -1.0;
	verts[1]  = 1.0;

	verts[2]  = 1.0/(DRAW_COORD_WIDTH/2.0) - 1.0;
	verts[3]  = 1.0;
	
	verts[4] = 1.0/(DRAW_COORD_WIDTH/2.0) - 1.0;
	verts[5] = 1.0 - 1.0/(DRAW_COORD_HEIGHT/2.0);
	


	verts[6] = 1.0/(DRAW_COORD_WIDTH/2.0) - 1.0;
	verts[7] = 1.0 - 1.0/(DRAW_COORD_HEIGHT/2.0);
	
	verts[8] = -1.0;
	verts[9] = 1.0 - 1.0/(DRAW_COORD_HEIGHT/2.0);

	verts[10] = -1.0;
	verts[11] = 1.0;
	/* */

	if(glfwInit() == -1)
	{
		printf("Error during glfw_Init()\n");
		exit(1);
	}

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);


	window = glfwCreateWindow(_width, _height, "fuck my fucking life why the fuck won't this work... hey maybe it's not that bad", NULL, NULL);
	
	if (!window)
	{
		printf("Error during glfwCreateWindow(...)\n");
		exit(2);
	}


	glfwMakeContextCurrent(window);
	gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);


	GLuint vao;
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	GLuint vbo;
	glGenBuffers(1, &vbo);

	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);

	
	GLint status;
	const GLchar* fragmentSource_ = "#version 150\n"
									"uniform vec3 triColor;\n"
									"out vec4 outColor;\n"
									"\n"
									"void main()\n"
									"{\n"
									"	outColor = vec4(triColor, 1.0);\n"
									"}\n";
	printf(fragmentSource_);
	const GLchar* vertexSource_   = "#version 150\n"
									"uniform vec2 coords;\n"
									"uniform float offsetx;\n"
									"uniform float offsety;\n"
									"in vec2 position;\n"
									"\n"
									"void main()\n"
									"{\n"
									"	float a = offsetx + offsety;\n"
									"	gl_Position = vec4(position.x, position.y, 0.0, 1.0);\n"
									"}\n";
	printf(vertexSource_);
	const GLchar** vertexSource   = &vertexSource_;
	const GLchar** fragmentSource = &fragmentSource_;
	

	GLuint fragmentShader         = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, fragmentSource, NULL);
	glCompileShader(fragmentShader);
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &status);
	if (status != GL_TRUE)
	{
		char buffer[512];
		glGetShaderInfoLog(fragmentShader, 512, NULL, buffer);
		printf("Error compiling the fragment shader.\n%s\n", buffer);
		exit(4);
	}

	GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, vertexSource, NULL);
	glCompileShader(vertexShader);
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &status);
	if (status != GL_TRUE)
	{
		char buffer[512];
		glGetShaderInfoLog(vertexShader, 512, NULL, buffer);
		printf("Error compiling the vertex shader.\n%s\n", buffer);
		exit(5);
	}

	

	GLuint shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glBindFragDataLocation(shaderProgram, 0, "outColor");
	glLinkProgram(shaderProgram);
	glUseProgram(shaderProgram);


	GLint posAttrib = glGetAttribLocation(shaderProgram, "position");
	glEnableVertexAttribArray(posAttrib);
	glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 2*sizeof(float), 0);

	offsetx		= glGetUniformLocation(shaderProgram, "offsetx");
	offsety		= glGetUniformLocation(shaderProgram, "offsety");
	coords		= glGetUniformLocation(shaderProgram, "coords");

	printf("(%d)WIDTH:  %.5f\n(%d)HEIGHT: %.5f\n", offsetx, 1.0/DRAW_COORD_WIDTH, offsety, 1.0/DRAW_COORD_HEIGHT);
	float offset1 = 0.05;
	float offset2 = 0.05;
	glUniform1f(offsetx, offset1);
	glUniform1f(offsety, offset2);
	//glUniform2f(offset, 1.0/((float)DRAW_COORD_WIDTH), 1.0/((float)DRAW_COORD_HEIGHT));

}

int draw_should_close()
{
	return glfwWindowShouldClose(window);
}

void draw_poll_events()
{
	glfwPollEvents();
}

void draw_end()
{
	glDeleteProgram(shaderProgram);
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	glDeleteBuffers(1, &vbo);
	glDeleteVertexArrays(1, &vao);

	glfwDestroyWindow(window);
	glfwTerminate();
}
